%% PART_1: Create 3D Point Clouds Based on Selected Function


%object and shape function
[objV, objF] = readObj('bunny.obj');  

shapeFunc3D = @(x,y,z) arrayfun( @(xi,yi,zi) ...
                     isPointInsideMesh([xi,yi,zi], objV, objF), ...
                     x, y, z );

%Choose the function yourself!
Haha = 1e-3
densityFunc3D = @(x,y,z) 1 + sin(pi*x); %1.*(x>=0) + 10.*(x<0); %( x.^2 + y.^2 + z.^2 + Haha ).^(-2);

%BCs
minV = min(objV,[],1);
maxV = max(objV,[],1);
bbox3 = [minV; maxV];  % [xmin ymin zmin; xmax ymax zmax]
fprintf('X spans [%g, %g]\n', minV(1), maxV(1));
fprintf('Y spans [%g, %g]\n', minV(2), maxV(2));
fprintf('Z spans [%g, %g]\n', minV(3), maxV(3));

%Tried max can run: 50000; the max points without a super long running time: 5000; max for a good plot:
%500
N = 500;
[pts3, dens3] = generatePointCloud3D(shapeFunc3D, bbox3, N, densityFunc3D);


figure;
h = patch( ...
    'Vertices', objV, ...
    'Faces',    objF, ...
    'FaceColor', [0.8,0.8,0.9], ...   
    'EdgeColor', 'none', ...
    'FaceAlpha', 0.3 );          
hold on;
scatter3(pts3(:,1), pts3(:,2), pts3(:,3), 8, dens3, 'filled');
axis equal tight vis3d
axis on; grid on; box on
xlabel('x'); ylabel('y'); zlabel('z');
camlight headlight
lighting gouraud
title('3D point cloud');
colorbar;
ax   = gca;
xL   = xlim(ax); yL = ylim(ax); zL = zlim(ax);
L    = 0.2 * max([range(xL), range(yL), range(zL)]);
hold on
quiver3(0,0,0,  L,0,0,  0, 'LineWidth',1.8, 'Color',[0.85 0.1 0.1]); 
quiver3(0,0,0,  0,L,0,  0, 'LineWidth',1.8, 'Color',[0.10 0.6 0.10]); 
quiver3(0,0,0,  0,0,L,  0, 'LineWidth',1.8, 'Color',[0.10 0.30 0.90]);
text(L,0,0, '  x', 'Color',[0.85 0.1 0.1], 'FontWeight','bold', 'VerticalAlignment','middle');
text(0,L,0, '  y', 'Color',[0.10 0.6 0.10], 'FontWeight','bold', 'VerticalAlignment','middle');
text(0,0,L, '  z', 'Color',[0.10 0.30 0.90], 'FontWeight','bold', 'VerticalAlignment','middle');


% origin checking
originInside = isPointInsideMesh([0,0,0], objV, objF);
if originInside
    disp('The origin lies inside the mesh.');
else
    disp('The origin lies outside the mesh.');
end


% generatePointCloud3D func; rejection sampling: to make it proportional to our density func
function [pts, dens] = generatePointCloud3D(shapeFunc, bbox, N, densityFunc)
    
    if nargin < 4 || isempty(densityFunc)
        densityFunc = @(x,y,z) 1;
    end
    
    gx = linspace(bbox(1,1), bbox(2,1), 30);
    gy = linspace(bbox(1,2), bbox(2,2), 30);
    gz = linspace(bbox(1,3), bbox(2,3), 30);
    [Xg,Yg,Zg] = ndgrid(gx,gy,gz);
    maskG = shapeFunc(Xg(:), Yg(:), Zg(:));
    rhoMax = max( densityFunc( Xg(maskG), Yg(maskG), Zg(maskG) ) );

    pts  = zeros(N,3);
    dens = zeros(N,1);
    count = 0;

    while count < N
        B = min(5*(N-count), 20000);
        Xc = bbox(1,1) + (bbox(2,1)-bbox(1,1)).*rand(B,1);
        Yc = bbox(1,2) + (bbox(2,2)-bbox(1,2)).*rand(B,1);
        Zc = bbox(1,3) + (bbox(2,3)-bbox(1,3)).*rand(B,1);

        inMask = shapeFunc(Xc, Yc, Zc);
        Xc = Xc(inMask);  Yc = Yc(inMask);  Zc = Zc(inMask);
        if isempty(Xc), continue; end

        r = densityFunc(Xc, Yc, Zc) ./ rhoMax;
        keep = rand(size(r)) <= r;

        Xk = Xc(keep);  Yk = Yc(keep);  Zk = Zc(keep);
        nk   = numel(Xk);
        take = min(nk, N-count);

        if take>0
            idx = count + (1:take);
            pts(idx,:)  = [Xk(1:take), Yk(1:take), Zk(1:take)];
            dens(idx)   = densityFunc( Xk(1:take), Yk(1:take), Zk(1:take) );
            count = count + take;
        end
    end
end

%OBJ solver
function [V,F] = readObj(filename)
    fid = fopen(filename,'r');
    if fid<0, error('Could not open %s', filename); end
    V = [];  F = [];
    while true
        tline = fgetl(fid);
        if ~ischar(tline), break; end
        tline = strtrim(tline);
        if startsWith(tline,'v ')
            coords = sscanf(tline(2:end),'%f %f %f');
            V(end+1,:) = coords';    
        elseif startsWith(tline,'f ')
            parts = strsplit(tline);
            idx = zeros(1, numel(parts)-1);
            for k=2:numel(parts)
                tok = strsplit(parts{k}, '/');
                idx(k-1) = str2double(tok{1});
            end
            if numel(idx)==3
                F(end+1,:) = idx;   
            end
        end
    end
    fclose(fid);
end

%faces
function inside = isPointInsideMesh(point, V, F)

    O = point(:)';  D = [1 0 0];  tol = 1e-8;
    V0 = V(F(:,1),:);  V1 = V(F(:,2),:);  V2 = V(F(:,3),:);
    E1 = V1 - V0;      E2 = V2 - V0;
    H  = cross(repmat(D,size(E2,1),1), E2, 2);
    A  = dot(E1, H, 2);
    valid = abs(A) > tol;
    invA  = zeros(size(A));  invA(valid) = 1 ./ A(valid);
    S  = repmat(O, size(E1,1),1) - V0;
    U  = invA .* dot(S, H, 2);
    maskU = valid & U>=0 & U<=1;
    Q  = cross(S, E1, 2);
    Vv = invA .* dot(repmat(D,size(Q,1),1), Q, 2);
    maskV = maskU & Vv>=0 & (U+Vv)<=1;
    T  = invA .* dot(E2, Q, 2);
    hits = maskV & (T > tol);
    inside = mod(nnz(hits),2)==1;
end

numVertices = size(objV,1);
fprintf('This mesh has %d vertices.\n', numVertices);


%% PART_2: 2D Projection: a simple Monge OT.

X = pts3;      
N = size(X,1);
Z0 = 0; % z=0 plane

% OT map
Y2 = X(:,1:2);
dist = abs(X(:,3) - Z0);
fprintf('Total cost = %.6g, mean = %.6g\n', ...
        sum(dist), mean(dist));


% 2D points plot
figure('Color','w');
scatter(Y2(:,1), Y2(:,2), 24, ...
        'filled', 'MarkerFaceColor',[0.10 0.70 0.10], ...
        'MarkerEdgeColor','k', 'LineWidth',0.25);
axis equal tight off
title('Monge map to z-plane');

% show the transportation
Xproj = [X(:,1), X(:,2), Z0*ones(N,1)];
figure('Color','w'); hold on
patch('Vertices',objV,'Faces',objF,'FaceColor',[0.8 0.8 0.9],'EdgeColor','none','FaceAlpha',0.15);
plot3([X(:,1) Xproj(:,1)]', [X(:,2) Xproj(:,2)]', [X(:,3) Xproj(:,3)]', 'k-', 'LineWidth', 0.5);
scatter3(X(:,1), X(:,2), X(:,3), 20, dist, 'filled'); 
scatter3(Xproj(:,1), Xproj(:,2), Xproj(:,3), 15, 'filled', ...
         'MarkerFaceColor',[0.10 0.70 0.10], 'MarkerEdgeColor','k', 'LineWidth',0.25);
xlabel('x'); ylabel('y'); zlabel('z'); title('Projection to z=0');
camlight headlight; lighting gouraud


%% PART_3: Setup

% curved plane
bend = -1;   %curvature
xy0  = mean(Y2,1); 
rxy  = sqrt(sum((Y2 - xy0).^2, 2));
rmax = max(rxy);
R    = 1.25 * rmax;  
C    = [xy0(1), xy0(2), bend*R]; 


dx = Y2(:,1) - C(1);
dy = Y2(:,2) - C(2);
r2 = dx.^2 + dy.^2;


r2max = max(r2);
if r2max >= R^2
    R = sqrt(r2max) * 1.01;
    C(3) = bend*R;
end

Zsag = C(3) - bend * sqrt(max(R^2 - r2, 0));
Y2_curved3D = [Y2, Zsag]; 
Center3D    = C;

figure('Color','w'); hold on
scatter3(Y2_curved3D(:,1), Y2_curved3D(:,2), Y2_curved3D(:,3), 12, 'filled', ...
         'MarkerEdgeColor','k', 'LineWidth', 0.25);
plot3(Center3D(1), Center3D(2), Center3D(3), 'rp', ...
      'MarkerFaceColor','y', 'MarkerSize', 12); 
axis equal vis3d; grid on; box on
xlabel('x'); ylabel('y'); zlabel('z');


% reflector
R_reflect     = 1.0; % radius
theta_ref_deg = 55;    % angle; relate to width
Center_ref    = [0, -0.5, -0.5];  % reflector center

res_r = 120; res_t = 180;
th = theta_ref_deg*pi/180;
rho = linspace(0, th,    res_r);
phi = linspace(0, 2*pi,  res_t);
[RHO, PHI] = meshgrid(rho, phi);
Xl = R_reflect .* sin(RHO) .* cos(PHI);
Yl = R_reflect .* sin(RHO) .* sin(PHI);
Zl = R_reflect .* cos(RHO);

rot_x_deg = 0;   % x rotation
rot_y_deg = 0;   % y rotation
ax = rot_x_deg*pi/180;
ay = rot_y_deg*pi/180;
Rx = [1 0 0;
      0 cos(ax) -sin(ax);
      0 sin(ax)  cos(ax)];
Ry = [ cos(ay) 0 sin(ay);
       0       1 0;
      -sin(ay) 0 cos(ay)];

P  = [Xl(:)'; Yl(:)'; Zl(:)'];
P  = Rx * (Ry * P); % x first then y

Xr = reshape(P(1,:), size(Xl)) + Center_ref(1);
Yr = reshape(P(2,:), size(Yl)) + Center_ref(2);
Zr = reshape(P(3,:), size(Zl)) + Center_ref(3);

figure(gcf); hold on; set(gcf,'Renderer','opengl');
if exist('Center3D','var'), plot3(Center3D(1),Center3D(2),Center3D(3),'r*'); end
plot3(Center_ref(1),Center_ref(2),Center_ref(3),'ks','MarkerFaceColor','y','MarkerSize',8);

axis equal vis3d; grid on; box on; xlabel x; ylabel y; zlabel z;
surf(Xr, Yr, Zr, ...
     'FaceColor',[0.20 0.40 0.95], ... 
     'FaceAlpha',0.45, ...
     'EdgeColor','none');
title(sprintf('OT', R_reflect, theta_ref_deg));


%% PART_4: OT

S = Center3D(:).'; % light sourced
D = Y2_curved3D - S; % S+tD
D = D ./ vecnorm(D,2,2);

%D^2t^2+2D(S-C)t+(S-C)^2-R^2
oc   = S - Center_ref; 
b    = 2*(D*oc(:));
c    = dot(oc,oc) - R_reflect^2;
disc = b.^2 - 4*c;

t1 = (-b - sqrt(max(disc,0))) / 2;
t2 = (-b + sqrt(max(disc,0))) / 2;
t1(t1<=0) = inf; t2(t2<=0) = inf;  % IMPORTANT: only reflector above source plane
t_hit = min(t1,t2);
hit_refl = isfinite(t_hit);

H = S + t_hit.*D; 
H(~hit_refl,:) = NaN;


% mirror law: d-2(dn)n

N   = (H - Center_ref) ./ R_reflect;
N   = N ./ vecnorm(N,2,2);
dotDN = sum(D.*N,2);
Rdir  = D - 2*dotDN.*N; 


Zdet = -2; 
Ydet = -3; 
Xdet = -1.5;

tz  = (Zdet - H(:,3))./Rdir(:,3);  mxy = hit_refl & tz>0  & abs(Rdir(:,3))>1e-12;  Pxy = H + tz.*Rdir;  Pxy(~mxy,:) = NaN;
ty  = (Ydet - H(:,2))./Rdir(:,2);  mxz = hit_refl & ty>0  & abs(Rdir(:,2))>1e-12;  Pxz = H + ty.*Rdir;  Pxz(~mxz,:) = NaN;
tx  = (Xdet - H(:,1))./Rdir(:,1);  myz = hit_refl & tx>0  & abs(Rdir(:,1))>1e-12;  Pyz = H + tx.*Rdir;  Pyz(~myz,:) = NaN;

% plot section
figure(gcf); hold on;
scatter3(Pxy(mxy,1), Pxy(mxy,2), Pxy(mxy,3), 12, [0 0.6 0], 'filled');
%scatter3(Pxz(mxz,1), Pxz(mxz,2), Pxz(mxz,3), 10, [0.1 0.3 0.9], 'filled');
%scatter3(Pyz(myz,1), Pyz(myz,2), Pyz(myz,3), 10, [0.9 0.3 0.1], 'filled');

M = size(D,1);
fprintf('Rays: %d | reflector hits: %d | XY hits: %d | XZ hits: %d | YZ hits: %d\n', ...
    M, sum(hit_refl), sum(mxy), sum(mxz), sum(myz));

figure('Color','w'); t = tiledlayout(1,3,'Padding','compact','TileSpacing','compact');
nexttile; scatter(Pxy(mxy,1), Pxy(mxy,2), 6, 'filled'); axis equal tight; grid on; title(sprintf('XY (z=%.3g)', Zdet));
nexttile; scatter(Pxz(mxz,1), Pxz(mxz,3), 6, 'filled'); axis equal tight; grid on; title(sprintf('XZ (y=%.3g)', Ydet));
nexttile; scatter(Pyz(myz,2), Pyz(myz,3), 6, 'filled'); axis equal tight; grid on; title(sprintf('YZ (x=%.3g)', Xdet));











